// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: password_query.sql

package dbsqlc

import (
	"context"
	"time"

	typeid "go.jetify.com/typeid/v2"
)

const changePasswordCredentialEmailByUserID = `-- name: ChangePasswordCredentialEmailByUserID :exec
UPDATE shield_user_credentials
SET user_credential_key = $1
WHERE user_id = $2 AND name = 'password'
`

type ChangePasswordCredentialEmailByUserIDParams struct {
	Email  string
	UserID typeid.TypeID
}

func (q *Queries) ChangePasswordCredentialEmailByUserID(ctx context.Context, db DBTX, arg ChangePasswordCredentialEmailByUserIDParams) error {
	_, err := db.Exec(ctx, changePasswordCredentialEmailByUserID, arg.Email, arg.UserID)
	return err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec
DELETE FROM shield_password_reset_tokens WHERE expires_at < now() RETURNING id
`

func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const findPasswordResetToken = `-- name: FindPasswordResetToken :one
SELECT id, created_at, updated_at, is_used, token, expires_at, user_id
FROM shield_password_reset_tokens
WHERE token = $1
LIMIT 1 AND expires_at > now()
`

func (q *Queries) FindPasswordResetToken(ctx context.Context, db DBTX, token string) (ShieldPasswordResetToken, error) {
	row := db.QueryRow(ctx, findPasswordResetToken, token)
	var i ShieldPasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsUsed,
		&i.Token,
		&i.ExpiresAt,
		&i.UserID,
	)
	return i, err
}

const findUserWithPasswordCredentialByEmail = `-- name: FindUserWithPasswordCredentialByEmail :one
SELECT u.id, u.created_at, u.updated_at, u.email, u.is_email_verified, credential.user_credential_secret AS password_hash
FROM
  shield_users AS u
  JOIN shield_user_credentials AS credential
    ON credential.user_id = u.id
    AND credential.name = 'password'
    AND credential.user_credential_key = $1
WHERE u.email = $1
`

type FindUserWithPasswordCredentialByEmailRow struct {
	ID              typeid.TypeID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Email           string
	IsEmailVerified bool
	PasswordHash    string
}

func (q *Queries) FindUserWithPasswordCredentialByEmail(ctx context.Context, db DBTX, email string) (FindUserWithPasswordCredentialByEmailRow, error) {
	row := db.QueryRow(ctx, findUserWithPasswordCredentialByEmail, email)
	var i FindUserWithPasswordCredentialByEmailRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordHash,
	)
	return i, err
}

const findUserWithPasswordCredentialByUserID = `-- name: FindUserWithPasswordCredentialByUserID :one
SELECT shield_user.id, shield_user.created_at, shield_user.updated_at, shield_user.email, shield_user.is_email_verified, credential.user_credential_secret AS password_hash
FROM
  shield_users AS shield_user
  LEFT JOIN shield_user_credentials AS credential
    ON credential.user_id = shield_user.id
    AND credential.name = 'password'
    AND credential.user_credential_key = shield_user.email
WHERE shield_user.id = $1
`

type FindUserWithPasswordCredentialByUserIDRow struct {
	ID              typeid.TypeID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Email           string
	IsEmailVerified bool
	PasswordHash    *string
}

func (q *Queries) FindUserWithPasswordCredentialByUserID(ctx context.Context, db DBTX, userID typeid.TypeID) (FindUserWithPasswordCredentialByUserIDRow, error) {
	row := db.QueryRow(ctx, findUserWithPasswordCredentialByUserID, userID)
	var i FindUserWithPasswordCredentialByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.PasswordHash,
	)
	return i, err
}

const markPasswordResetTokenAsUsed = `-- name: MarkPasswordResetTokenAsUsed :exec
UPDATE shield_password_reset_tokens
SET is_used = TRUE
WHERE token = $1
`

func (q *Queries) MarkPasswordResetTokenAsUsed(ctx context.Context, db DBTX, token string) error {
	_, err := db.Exec(ctx, markPasswordResetTokenAsUsed, token)
	return err
}

const upsertPasswordCredentialByUserID = `-- name: UpsertPasswordCredentialByUserID :exec
WITH
  credential AS (
    INSERT INTO shield_user_credentials
      (id, name, user_id, user_credential_key, user_credential_secret)
    VALUES
      ($1, 'password', $2, $3, $4)
    ON CONFLICT (name, user_credential_key) DO UPDATE
      SET user_credential_secret = $4
    RETURNING id
  )
SELECT id
FROM credential
`

type UpsertPasswordCredentialByUserIDParams struct {
	ID                   typeid.TypeID
	UserID               typeid.TypeID
	UserCredentialKey    string
	UserCredentialSecret string
}

func (q *Queries) UpsertPasswordCredentialByUserID(ctx context.Context, db DBTX, arg UpsertPasswordCredentialByUserIDParams) error {
	_, err := db.Exec(ctx, upsertPasswordCredentialByUserID,
		arg.ID,
		arg.UserID,
		arg.UserCredentialKey,
		arg.UserCredentialSecret,
	)
	return err
}

const upsertPasswordResetToken = `-- name: UpsertPasswordResetToken :one
WITH
  token AS (
    INSERT INTO shield_password_reset_tokens
      (id, user_id, token, expires_at, is_used)
    VALUES
      ($1, $2, $3, $4, FALSE)
    ON CONFLICT (user_id, is_used) DO UPDATE
      SET expires_at = greatest(
        excluded.expires_at,
        shield_password_reset_tokens.expires_at
      )
    RETURNING token, id, expires_at
  )
SELECT token, id, expires_at
FROM token
`

type UpsertPasswordResetTokenParams struct {
	ID        typeid.TypeID
	UserID    typeid.TypeID
	Token     string
	ExpiresAt time.Time
}

type UpsertPasswordResetTokenRow struct {
	Token     string
	ID        string
	ExpiresAt time.Time
}

func (q *Queries) UpsertPasswordResetToken(ctx context.Context, db DBTX, arg UpsertPasswordResetTokenParams) (UpsertPasswordResetTokenRow, error) {
	row := db.QueryRow(ctx, upsertPasswordResetToken,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
	)
	var i UpsertPasswordResetTokenRow
	err := row.Scan(&i.Token, &i.ID, &i.ExpiresAt)
	return i, err
}
