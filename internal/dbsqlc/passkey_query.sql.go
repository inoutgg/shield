// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: passkey_query.sql

package dbsqlc

import (
	"context"
	"time"

	typeid "go.jetify.com/typeid/v2"
)

const createUserPasskeyCredential = `-- name: CreateUserPasskeyCredential :exec
INSERT INTO shield_user_credentials
  (id, name, user_id, user_credential_key, user_credential_secret)
VALUES
  ($1, 'passkey', $2, $3, $4)
`

type CreateUserPasskeyCredentialParams struct {
	ID                   typeid.TypeID
	UserID               typeid.TypeID
	UserCredentialKey    string
	UserCredentialSecret string
}

func (q *Queries) CreateUserPasskeyCredential(ctx context.Context, db DBTX, arg CreateUserPasskeyCredentialParams) error {
	_, err := db.Exec(ctx, createUserPasskeyCredential,
		arg.ID,
		arg.UserID,
		arg.UserCredentialKey,
		arg.UserCredentialSecret,
	)
	return err
}

const findUserWithPasskeyCredentialByEmail = `-- name: FindUserWithPasskeyCredentialByEmail :one
SELECT u.id, u.created_at, u.updated_at, u.email, u.is_email_verified, credential.user_credential_secret::JSON AS user_credential
FROM
  shield_users AS u
  JOIN shield_user_credentials AS credential
    ON credential.user_id = u.id
    AND credential.name = 'passkey'
    AND credential.user_credential_key = $1
WHERE u.email = $1
`

type FindUserWithPasskeyCredentialByEmailRow struct {
	ID              typeid.TypeID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Email           string
	IsEmailVerified bool
	UserCredential  []byte
}

func (q *Queries) FindUserWithPasskeyCredentialByEmail(ctx context.Context, db DBTX, email string) (FindUserWithPasskeyCredentialByEmailRow, error) {
	row := db.QueryRow(ctx, findUserWithPasskeyCredentialByEmail, email)
	var i FindUserWithPasskeyCredentialByEmailRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.UserCredential,
	)
	return i, err
}
